
  function calculateDeltaP(pressure, temputre, flowRateN, pressureDropAllowed,sheetThickness,holesDiametre, numberHoles) {
    const densityGas0 = 1.27;
    const densityGas = 0.0285 * pressure / (8.314 * temputre);
    const speedSound = (1.4 * 8.314 * temputre / 0.0285)**0.5;
    const flowRate = flowRateN * densityGas0 / densityGas;
    const flowRateF = flowRate / 60;
    const crossAreas = 1.38;
    const speedPerforatedSheet = flowRateF / crossAreas;
  
    const freeSpace =numberHoles * Math.PI * 0.25 * (holesDiametre * 0.001) ** 2;
    const speed = flowRateF / freeSpace;
    const reynoldsNumber = (speed * holesDiametre * 0.001) / (1.7 * 0.00001);
        
    const areaRatioGrid = freeSpace / crossAreas;
    
    const index = sheetThickness / holesDiametre;
    
    const indexList = [0, 0.2, 0.4, 0.6, 0.8, 1, 1.4, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const tau = [1.35, 1.22, 1.1, 0.84, 0.42, 0.24, 0.1, 0.02, 0, 0, 0, 0, 0, 0, 0, 0];
                  

    let y_preduction = 0;
    for (let i = 0; i < indexList.length; i++) {
      if (index === indexList[i]) {
        y_preduction = tau[i];
      } if (indexList[i] < index && indexList[i + 1] > index) {
          y_preduction = tau[i]  + ((index - indexList[i]) * (tau[i+1] - tau[i])) / (indexList[i+1] - indexList[i]);
        
          
      } 
      
    }
  
    const areaRatioList = [0, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95];
    const reynoldsList = [25, 40, 60, 100, 200, 400, 1000, 2000, 4000, 10000, 20000, 100000, 200000, 1000000];
    const epsilonReynoldsList = [0.34, 0.36, 0.37, 0.4, 0.42, 0.46, 0.53, 0.59, 0.64, 0.74, 0.81, 0.94, 0.95, 0.98];
  
    const zetaPhiMatrix = [
      [1.94, 1.38, 1.14, 0.89, 0.59, 0.64, 0.39, 0.3, 0.22, 0.15, 0.11, 0.04, 0.01, 0],
      [1.78, 1.36, 1.05, 0.85, 0.67, 0.57, 0.36, 0.26, 0.2, 0.13, 0.09, 0.03, 0.01, 0],
      [1.57, 1.16, 0.88, 0.75, 0.57, 0.43, 0.3, 0.22, 0.17, 0.1, 0.07, 0.02, 0.01, 0],
      [1.35, 0.99, 0.79, 0.57, 0.4, 0.28, 0.19, 0.14, 0.1, 0.06, 0.04, 0.02, 0.01, 0],
      [1.1, 0.75, 0.55, 0.34, 0.19, 0.12, 0.07, 0.05, 0.03, 0.02, 0.01, 0.01, 0],
      [0.85, 0.56, 0.3, 0.19, 0.1, 0.06, 0.03, 0.02, 0.01, 0, 0, 0, 0],
      [0.58, 0.37, 0.23, 0.11, 0.06, 0.03, 0.02, 0.01, 0, 0, 0, 0, 0, 0],
      [0.4, 0.24, 0.13, 0.06, 0.03, 0.02, 0.01, 0, 0, 0, 0, 0, 0, 0],
      [0.2, 0.13, 0.08, 0.03, 0.01, 0, 0, 0, 0, 0, 0, 0, 0, 0,],
      [0.03, 0.03, 0.02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
  
    let a = 0;
    let b = 0;
    let a1 = 0;
    let b1 = 0;
    let a2 = 0;
    let b2 = 0;
    let X1 = 0;
    let X2 = 0;
    let Y1 = 0;
    let Y2 = 0;
  
    for (let i = 0; i < areaRatioList.length - 1; i++) {
      if (areaRatioGrid === areaRatioList[i]) {
        
        a = i;
      } else {
        if (areaRatioList[i] < areaRatioGrid && areaRatioList[i + 1] > areaRatioGrid) {
          X1 = areaRatioList[i];
          X2 = areaRatioList[i + 1];
          a1 = i;
          b1 = i + 1;
        } else {
          X1 = 0.0001;
          X2 = 1;
        }
      }
    }
  
    let eps1 = 0;
    let eps2 = 0;
  
    for (let i = 0; i < reynoldsList.length - 1; i++) {
      if (reynoldsNumber === reynoldsList[i]) {
        
        b = i;
      } else {
        if (reynoldsList[i] < reynoldsNumber && reynoldsList[i + 1] > reynoldsNumber) {
          Y1 = reynoldsList[i];
          Y2 = reynoldsList[i + 1];
          a2 = i;
          b2 = i + 1;
          eps1 = epsilonReynoldsList[i];
          eps2 = epsilonReynoldsList[i + 1];
        } else {
          Y1 = 10;
          Y2 = 10000000;
        }
      }
    }
  
    const z11 = zetaPhiMatrix[a1][a2];
    const z12 = zetaPhiMatrix[a1][b2];
    const z21 = zetaPhiMatrix[b1][a2];
    const z22 = zetaPhiMatrix[b1][b2];
  
    const Z_phi = 1 / ((X2 - X1) * (Y2 - Y1)) * (z11 * (X2 - areaRatioGrid) * (Y2 - reynoldsNumber) + z21 * (areaRatioGrid - X1) * (Y2 - reynoldsNumber) + z12 * (X2 - areaRatioGrid) * (reynoldsNumber - Y1) + z22 * (areaRatioGrid - X1) * (reynoldsNumber - Y1));
  
    const epsilonCorrect = eps1 + (eps2 - eps1) / ((Y2 - Y1) * (index - Y1));
    const lamda = 0.3164/(reynoldsNumber**0.25); 

    const ZetaSharpTurbulent= ((1 + 0.707 * Math.sqrt(1 - areaRatioGrid) - areaRatioGrid) / areaRatioGrid) ** 2;
    const ZetaSharpTransitional = (Z_phi + epsilonCorrect * (1 + 0.707 * Math.sqrt(1 - areaRatioGrid) - areaRatioGrid) ** 2) / areaRatioGrid ** 2;
    const ZetaThickTurbulent = (0.5 * (1 - areaRatioGrid) + y_preduction * (1 - areaRatioGrid) ** 1.5 +(1-areaRatioGrid)**2+ lamda * index) / areaRatioGrid ** 2;
    const ZetaThickTransitional = (Z_phi + epsilonCorrect * (0.5 * (1 - areaRatioGrid) + y_preduction * (1 - areaRatioGrid) ** 1.5 + (1 - areaRatioGrid) ** 2) + lamda * index) / areaRatioGrid ** 2;
  
    let compressibilityFactor = 0;
    const machNunmber = speed / speedSound;
    let Z = 0;
  
    if (machNunmber < 0.3) {
      compressibilityFactor = 1;
    } else {
      compressibilityFactor = 35.252 * machNunmber ** 4 - 28.883 * machNunmber ** 3 + 8.1252 * machNunmber ** 2 - 0.6808 * machNunmber + 1;
    }
  
    if (index < 0.015) {
      if (reynoldsNumber < 100000) {
        Z = ZetaSharpTransitional*compressibilityFactor;
      } else {
        Z = ZetaSharpTurbulent*compressibilityFactor;
      }
    } else {
      if (reynoldsNumber < 100000) {
        Z = ZetaThickTransitional*compressibilityFactor;
      } else {
        Z = ZetaThickTurbulent*compressibilityFactor;
      }
    }
  
    const pressureDropAllowedCalculated = 0.5 * Z * densityGas * speedPerforatedSheet ** 2 / 100;
  
    const pressureDifference = pressureDropAllowed -  pressureDropAllowedCalculated;
    return pressureDifference ;
  }
  
  const pressure = 166500;
  const temputre = 333;
  const flowRateN = 118.5;
  const pressureDropAllowed = 5;
  const sheetThickness = 16;
  const holesDiametre = 25;
  const numberHoles = 165;
  
  const result = calculateDeltaP(pressure, temputre, flowRateN, pressureDropAllowed, sheetThickness, holesDiametre, numberHoles);
  console.log('the pressor drop is : ', result);
